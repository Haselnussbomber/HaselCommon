using System.Security;
using System.Text;
using System.Text.Json;
using HaselCommon.TranslationGenerator.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

[Generator]
public class TranslationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var namespaceProvider = context.AnalyzerConfigOptionsProvider.Select((optionsProvider, _) =>
        {
            optionsProvider.GlobalOptions.TryGetValue("build_property.TranslationGenerator_Namespace", out var namespaceName);
            return namespaceName ?? "GeneratedTranslations";
        });

        var classNameProvider = context.AnalyzerConfigOptionsProvider.Select((optionsProvider, _) =>
        {
            optionsProvider.GlobalOptions.TryGetValue("build_property.TranslationGenerator_ClassName", out var className);
            return className ?? "Translations";
        });

        var parsedTranslations = context.AdditionalTextsProvider
            .Where(file => file.Path.EndsWith("Translations.json"))
            .Select((file, cancellationToken) => file.GetText(cancellationToken)?.ToString() ?? string.Empty)
            .Select((json, cancellationToken) => JsonSerializer.Deserialize<Dictionary<string, Dictionary<string, string>>>(json) ?? []);

        var combined = parsedTranslations
            .Combine(classNameProvider)
            .Combine(namespaceProvider);

        context.RegisterSourceOutput(combined, (spc, source) =>
        {
            var ((translations, className), namespaceName) = source;
            var code = GenerateSource(
                namespaceName,
                className,
                translations);
            spc.AddSource($"{namespaceName}.{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        });
    }

    private static string GenerateSource(
        string namespaceName,
        string className,
        Dictionary<string, Dictionary<string, string>> translations)
    {
        var writer = new IndentedTextWriter();

        writer.WriteLine("// <auto-generated>");
        writer.WriteLine();
        writer.WriteLine("using System;");
        writer.WriteLine("using System.Collections.Generic;");
        writer.WriteLine("using System.Text;");
        writer.WriteLine("using Dalamud.Game.Text.Evaluator;");
        writer.WriteLine("using Dalamud.Plugin.Services;");
        writer.WriteLine("using HaselCommon;");
        writer.WriteLine("using HaselCommon.Services;");
        writer.WriteLine("using Lumina.Text.ReadOnly;");
        writer.WriteLine("using Microsoft.Extensions.DependencyInjection;");
        writer.WriteLine();
        writer.WriteLine($"namespace {namespaceName};");
        writer.WriteLine();
        writer.WriteLine("[RegisterSingleton]");
        writer.WriteLine("[RegisterSingleton<ITranslationProvider>(Duplicate = DuplicateStrategy.Append)]");
        writer.WriteLine($"public partial class {className} : ITranslationProvider");

        using (writer.WriteBlock())
        {
            writer.WriteLine("protected readonly IServiceProvider _serviceProvider;");
            writer.WriteLine("protected readonly ISeStringEvaluator _seStringEvaluator;");
            writer.WriteLine("protected readonly LanguageProvider _languageProvider;");
            writer.WriteLine();
            writer.WriteLine($"public {className}(IServiceProvider serviceProvider)");

            using (writer.WriteBlock())
            {
                writer.WriteLine("_serviceProvider = serviceProvider;");
                writer.WriteLine("_seStringEvaluator = serviceProvider.GetRequiredService<ISeStringEvaluator>();");
                writer.WriteLine("_languageProvider = serviceProvider.GetRequiredService<LanguageProvider>();");
            }

            writer.WriteLine();
            GenerateTryGetTranslation(writer, translations);
            GenerateMacroStringCache(writer, translations);
            GenerateStringProperties(writer, translations);
            GenerateEvaluateFunctions(writer, translations);
        }

        return writer.ToString() + "\n";
    }

    private static void GenerateTryGetTranslation(in IndentedTextWriter writer, in Dictionary<string, Dictionary<string, string>> translations)
    {
        writer.WriteLine($@"public bool TryGetTranslation(string key, out string text)");

        using (writer.WriteBlock())
        {
            writer.WriteLine("switch (key)");
            using (writer.WriteBlock())
            {
                foreach (var kv in translations)
                {
                    writer.WriteLine($@"case ""{kv.Key}"":");
                    writer.IncreaseIndent();
                    writer.WriteLine($@"text = {MakeSafeIdentifier(kv.Key)};");
                    writer.WriteLine("return true;");
                    writer.DecreaseIndent();
                }

                writer.WriteLine("default:");
                writer.IncreaseIndent();
                writer.WriteLine("text = string.Empty;");
                writer.WriteLine("return false;");
                writer.DecreaseIndent();
            }
        }
    }

    private static void GenerateMacroStringCache(in IndentedTextWriter writer, in Dictionary<string, Dictionary<string, string>> translations)
    {
        foreach (var kv in translations)
        {
            if (!kv.Value.Any(kv => kv.Key == "_isSeString"))
                continue;

            writer.WriteLine();
            writer.WriteLine($"private readonly Dictionary<Language, ReadOnlySeString> {MakeSafeIdentifier(kv.Key)}MacroStringCache = new() {{");
            writer.IncreaseIndent();

            var summaryTranslations = new StringBuilder();
            for (var i = 0; i < kv.Value.Count; i++)
            {
                var entry = kv.Value.ElementAt(i);
                if (entry.Key == "_isSeString")
                    continue;

                writer.WriteLine($"[Language.{GetLanguage(entry.Key)}] = ReadOnlySeString.FromMacroString({GetStringLiteral(entry.Value, true)}),");
            }

            writer.DecreaseIndent();
            writer.WriteLine("};");
        }
    }

    private static void GenerateStringProperties(in IndentedTextWriter writer, in Dictionary<string, Dictionary<string, string>> translations)
    {
        foreach (var kv in translations)
        {
            GenerateStringProperty(writer, kv);
        }
    }

    private static void GenerateStringProperty(in IndentedTextWriter writer, in KeyValuePair<string, Dictionary<string, string>> translation)
    {
        var propertyName = MakeSafeIdentifier(translation.Key);

        writer.WriteLine();
        writer.WriteLine("/// <summary>");
        writer.WriteLine($"/// <c>{translation.Key}</c><br/>");
        writer.WriteLine("/// <list type=\"table\">");

        for (var i = 0; i < translation.Value.Count; i++)
        {
            var entry = translation.Value.ElementAt(i);
            if (entry.Key == "_isSeString")
                continue;

            var lang = GetLanguage(entry.Key);
            var text = SecurityElement.Escape(entry.Value.Replace("*/", "* /"));

            writer.WriteLine("///   <item>");
            writer.WriteLine($"///     <term>{lang}</term>");
            writer.WriteLine($"///     <description>{text}</description>");
            writer.WriteLine("///   </item>");
        }

        writer.WriteLine("/// </list>");
        writer.WriteLine("/// </summary>");

        if (translation.Value.Count > 1)
        {
            writer.WriteLine($@"public string {propertyName} => _languageProvider.Language switch");

            writer.WriteLine("{");
            writer.IncreaseIndent();

            string? defaultTextLiteral = null;

            foreach (var entry in translation.Value)
            {
                if (entry.Key == "_isSeString")
                    continue;

                var langCode = entry.Key;
                var text = entry.Value;
                var stringLiteral = GetStringLiteral(text);

                if (langCode == "en")
                {
                    defaultTextLiteral = stringLiteral;
                    continue;
                }

                writer.WriteLine($@"Language.{GetLanguage(langCode)} => {stringLiteral},");
            }

            writer.WriteLine($@"_ => {defaultTextLiteral ?? "string.Empty"}");

            writer.DecreaseIndent();
            writer.Write("}");

            writer.WriteLine(";");
        }
        else
        {
            writer.Write($@"public string {propertyName} => ");

            foreach (var entry in translation.Value)
            {
                if (entry.Key == "_isSeString")
                    continue;

                writer.WriteLine($@"{GetStringLiteral(entry.Value)};");
            }
        }
    }

    private static void GenerateEvaluateFunctions(in IndentedTextWriter writer, in Dictionary<string, Dictionary<string, string>> translations)
    {
        foreach (var kv in translations)
        {
            if (!kv.Value.Any(kv => kv.Key == "_isSeString"))
                continue;

            var propertyName = MakeSafeIdentifier(kv.Key);

            writer.WriteLine();
            writer.WriteLine("/// <summary>");
            writer.WriteLine($"/// <c>{kv.Key}</c><br/>");
            writer.WriteLine("/// <list type=\"table\">");

            var summaryTranslations = new StringBuilder();

            for (var i = 0; i < kv.Value.Count; i++)
            {
                var entry = kv.Value.ElementAt(i);
                if (entry.Key == "_isSeString")
                    continue;

                writer.WriteLine("///   <item>");
                writer.WriteLine($"///     <term>{GetLanguage(entry.Key)}</term>");
                writer.WriteLine($"///     <description>{SecurityElement.Escape(entry.Value.Replace("*/", "* /"))}</description>");
                writer.WriteLine("///   </item>");
            }

            writer.WriteLine("/// </list>");
            writer.WriteLine("/// </summary>");

            writer.WriteLine($@"public ReadOnlySeString Evaluate{propertyName}(params SeStringParameter[] parameters)");

            using (writer.WriteBlock())
            {
                writer.WriteLine("var language = _languageProvider.Language;");
                writer.WriteLine();
                writer.WriteLine($"if (!{propertyName}MacroStringCache.TryGetValue(_languageProvider.Language, out var text))");

                using (writer.WriteBlock())
                {
                    writer.WriteLine($"if (!{propertyName}MacroStringCache.TryGetValue(Language.English, out text))");
                    writer.IncreaseIndent();
                    writer.WriteLine("return default;");
                    writer.DecreaseIndent();
                    writer.WriteLine();
                    writer.WriteLine("language = Language.English;");
                }

                writer.WriteLine();
                writer.WriteLine("return _seStringEvaluator.Evaluate(text, parameters, language.ToClientLanguage());");
            }
        }
    }

    private static string GetLanguage(string langCode)
    {
        return langCode switch
        {
            "en" => "English",
            "de" => "German",
            "ja" => "Japanese",
            "fr" => "French",
            "it" => "Italian",
            "es" => "Spanish",
            "ko" => "Korean",
            "no" => "Norwegian",
            "ru" => "Russian",
            "zh" => "ChineseSimplified",
            "tw" => "ChineseTraditional",
            _ => throw new NotImplementedException()
        };
    }

    private static string MakeSafeIdentifier(string key)
    {
        var sb = new StringBuilder();
        foreach (var c in key)
        {
            if (char.IsLetterOrDigit(c) || c == '_')
                sb.Append(c);
            else
                sb.Append('_');
        }
        return sb.ToString();
    }

    private static string GetStringLiteral(string input, bool isUtf8 = false)
    {
        var sb = new StringBuilder();
        sb.Append('"');

        foreach (var c in input)
        {
            switch (c)
            {
                case '\\': sb.Append(@"\\"); break;
                case '\"': sb.Append("\\\""); break;
                case '\n': sb.Append(@"\n"); break;
                case '\r': sb.Append(@"\r"); break;
                case '\t': sb.Append(@"\t"); break;
                default:
                    if (char.IsControl(c))
                    {
                        sb.Append($"\\u{(int)c:x4}");
                    }
                    else
                    {
                        sb.Append(c);
                    }
                    break;
            }
        }

        if (isUtf8)
            sb.Append("\"u8");
        else
            sb.Append("\"");

        return sb.ToString();
    }
}
